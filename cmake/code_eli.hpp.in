/*********************************************************************************
* Copyright (c) 2013 David D. Marshall <ddmarsha@calpoly.edu>
*
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*    David D. Marshall - initial code and implementation
********************************************************************************/

#ifndef code_eli_hpp
#define code_eli_hpp

#define ELI_VERSION_MAJOR @ELI_VERSION_MAJOR@
#define ELI_VERSION_MINOR @ELI_VERSION_MINOR@
#define ELI_VERSION_PATCH @ELI_VERSION_PATCH@
#define ELI_VERSION "@ELI_VERSION_MAJOR@.@ELI_VERSION_MINOR@.@ELI_VERSION_PATCH@"
#define ELI_BUILD_TIMESTAMP @ELI_BUILD_DATE@.@ELI_BUILD_TIME@

// disable warnings from Eigen that still show up
#ifdef _MSC_VER
#elif defined __INTEL_COMPILER
  #pragma warning( push )
  #pragma warning disable 82 279 1595 2196 2536
#endif

// Visual Studio 2008 does not have cbrt(), asinh(), acosh(), atanh(), expm1() function
#ifdef _MSC_VER
# if (_MSC_VER<=1600)
    typedef int int32_t;
    typedef unsigned int uint32_t;
    typedef __int64 int64_t;
    typedef unsigned __int64 uint64_t;
#   define nullptr (0)
#   define _NEED_EXTRA_MATH_FUNCTIONS
#   define ELI_NO_VECTOR_DATA
# endif
#endif

#ifdef __INTEL_COMPILER
# if (__INTEL_COMPILER<1300)
#   define _NEED_EXTRA_MATH_FUNCTIONS
# endif
# if (__INTEL_COMPILER<1210)
#   define nullptr (0)
# endif
#endif

#ifdef _NEED_EXTRA_MATH_FUNCTIONS
# include <cmath>
namespace std
{
  inline float cbrt(float v) {return ((v<0)?(-1):(1))*std::pow(std::abs(v), 1.0f/3);}
  inline double cbrt(double v) {return ((v<0)?(-1):(1))*std::pow(std::abs(v), 1.0/3);}
  inline long double cbrt(long double v) {return ((v<0)?(-1):(1))*std::pow(std::abs(v), 1.0L/3);}

  inline float asinh(float v)
  {
    if(v>=0)
      return std::log(v + sqrt(v*v + 1));
    else
      return -std::log(-v + sqrt(v*v + 1));
  }
  inline double asinh(double v)
  {
    if(v>=0)
      return std::log(v + sqrt(v*v + 1));
    else
      return -std::log(-v + sqrt(v*v + 1));
  }
  inline long double asinh(long double v)
  {
    if(v>=0)
      return std::log(v + sqrt(v*v + 1));
    else
      return -std::log(-v + sqrt(v*v + 1));
  }

  inline float acosh(float v)
  {
    if(v>=0)
      return std::log(v - sqrt(v*v + 1));
    else
      return -std::log(-v - sqrt(v*v + 1));
  }
  inline double acosh(double v)
  {
    if(v>=0)
      return std::log(v - sqrt(v*v + 1));
    else
      return -std::log(-v - sqrt(v*v + 1));
  }
  inline long double acosh(long double v)
  {
    if(v>=0)
      return std::log(v - sqrt(v*v + 1));
    else
      return -std::log(-v - sqrt(v*v + 1));
  }

  inline float atanh(float v)
  {
    return std::log((1+v)/(1-v))/2;
  }
  inline double atanh(double v)
  {
    return std::log((1+v)/(1-v))/2;
  }
  inline long double atanh(long double v)
  {
    return std::log((1+v)/(1-v))/2;
  }

  inline float expm1(float v) {return std::exp(v)-1;}
  inline double expm1(double v) {return std::exp(v)-1;}
  inline long double expm1(long double v) {return std::exp(v)-1;}

  inline float exp2(float v) {return std::pow(2, v);}
  inline double exp2(double v) {return std::pow(2, v);}
  inline long double exp2(long double v) {return std::pow(2, v);}

  inline float log2(float v) {return std::log(v)/std::log(2.0f);}
  inline double log2(double v) {return std::log(v)/std::log(2.0);}
  inline long double log2(long double v) {return std::log(v)/std::log(2.0L);}

  inline float log1p(float v) {return std::log(1+v);}
  inline double log1p(double v) {return std::log(1+v);}
  inline long double log1p(long double v) {return std::log(1+v);}

  // based on "Handbook of Mathematical Functions"
  inline float erf(float v)
  {
    float a1(0.254829592f), a2(-0.284496736f), a3(1.421413741f), a4(-1.453152027f), a5(1.061405429f), p(0.3275911f);
    float t(1/(1+p*std::abs(v)));
    return ((v<0)?(-1):(1))*(a1+t*(a2+t*(a3+t*(a4+t*a5))))*t*std::exp(-v*v);
  }
  inline double erf(double v)
  {
    double a1(0.254829592), a2(-0.284496736), a3(1.421413741), a4(-1.453152027), a5(1.061405429), p(0.3275911);
    double t(1/(1+p*std::abs(v)));
    return ((v<0)?(-1):(1))*(a1+t*(a2+t*(a3+t*(a4+t*a5))))*t*std::exp(-v*v);
  }
  inline long double erf(long double v)
  {
    long double a1(0.254829592L), a2(-0.284496736L), a3(1.421413741L), a4(-1.453152027L), a5(1.061405429L), p(0.3275911L);
    long double t(1/(1+p*std::abs(v)));
    return ((v<0)?(-1):(1))*(a1+t*(a2+t*(a3+t*(a4+t*a5))))*t*std::exp(-v*v);
  }

  inline float erfc(float v) {return 1-erf(v);}
  inline double erfc(double v) {return 1-erf(v);}
  inline long double erfc(long double v) {return 1-erf(v);}
}
#endif
#undef _NEED_EXTRA_MATH_FUNCTIONS

// GCC versions 4.5 through latest (4.7) do not put these in the std namespace like they
// should be.
#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !defined(__clang__)
# if ( (__GNUC__<4) || ((__GNUC__==4) && (__GNUC_MINOR__<8)) )
#   include <cmath>

namespace std
{
  using ::asinh;
  using ::acosh;
  using ::atanh;
  using ::expm1;
  using ::exp2;
  using ::log2;
  using ::log1p;
  using ::erf;
  using ::erfc;
}
# endif

// GCC version 4.5 does not have nullptr defined
# if ( (__GNUC__<4) || ((__GNUC__==4) && (__GNUC_MINOR__<8)) )
#  define nullptr __null
# endif
#endif

// Clang versions 3.0 through latest (3.3) do not put these in the std namespace like they
// should be.
#ifdef __clang__
# if ( (__clang_major__ < 3) || ((__clang_major__==3) && (__clang_minor__<=3)) )
#   include <cmath>

namespace std
{
  using ::asinh;
  using ::acosh;
  using ::atanh;
  using ::expm1;
  using ::exp2;
  using ::log2;
  using ::log1p;
  using ::erf;
  using ::erfc;
}
# endif
#endif

#endif
